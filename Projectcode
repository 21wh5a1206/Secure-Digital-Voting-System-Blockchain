from django.template import RequestContext
from django.contrib import messages
from django.http import HttpResponse
from django.core.files.storage import FileSystemStorage
import os
from datetime import date
import cv2
import numpy as np
import base64
import random
from datetime import datetime
from PIL import Image
import json
from web3 import Web3, HTTPProvider
import face_recognition
global username, password, contact, email, aadhar, address, names, encodings
global contract, web3
global usersList, partyList, voteList
#function to call contract
def getContract():
    global contract, web3
    blockchain_address = 'http://127.0.0.1:9545'
    web3 = Web3(HTTPProvider(blockchain_address))
    web3.eth.defaultAccount = web3.eth.accounts[0]
    compiled_contract_path = 'Voting.json' #voting contract file
    deployed_contract_address = '0xd8a8e9202C03A93Eb20fEd7d34b84eDDE128c532' #contract address
    with open(compiled_contract_path) as file:
        contract_json = json.load(file)  # load contract info as JSON
        contract_abi = contract_json['abi']  # fetch contract's abi - necessary to call its functions
    file.close()
    contract = web3.eth.contract(address=deployed_contract_address, abi=contract_abi)
getContract()

def getUsersList():
    global usersList, contract
    usersList = []
    count = contract.functions.getUserCount().call()
    for i in range(0, count):
        user = contract.functions.getUsername(i).call()
        password = contract.functions.getPassword(i).call()
        email = contract.functions.getEmail(i).call()
        usersList.append([user, password, email,aadhar])

def getPartyList():
    global partyList, contract
    partyList = []
    count = contract.functions.getPartyCount().call()
    for i in range(0, count):
        cname = contract.functions.getCandidateName(i).call()
        pname = contract.functions.getPartyName(i).call()
        area = contract.functions.getArea(i).call()
        symbol = contract.functions.getSymbol(i).call()
        partyList.append([cname, pname, area, symbol])

def getVoteList():
    global voteList, contract
    voteList = []
    count = contract.functions.getVotingCount().call()
    for i in range(0, count):
        user = contract.functions.getUser(i).call()
        party = contract.functions.getParty(i).call()
        dd = contract.functions.getDate(i).call()
        candidate = contract.functions.getCandidate(i).call()
        voteList.append([user, party, dd, candidate])

def loadModel():
    global names, encodings
    if os.path.exists("model/encoding.npy"):
        encodings = np.load("model/encoding.npy")
        names = np.load("model/names.npy")        
    else:
        encodings = []
        names = []   

    
getUsersList()
getPartyList()        
getVoteList()
loadModel()

face_detection = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')

def alreadyCastVote(candidate):
    global voteList
    count = 0
    for i in range(len(voteList)):
        vl = voteList[i]
        if vl[3] == candidate:
            count = 1
    return count

def FinishVote(request):
    if request.method == 'GET':
        global username, voteList
        cname = request.GET.get('cname', False)
        pname = request.GET.get('pname', False)
        voter = ''
        today = date.today()
        status = 'Your vote casted to '+cname
        msg = contract.functions.createVote(username, pname, str(today), cname).transact()
        web3.eth.waitForTransactionReceipt(msg)
        voteList.append([username, pname, str(today), cname])
        context= {'data':'<font size=3 color=black>Your Vote Accepted for Candidate '+cname}
        return render(request, 'UserScreen.html', context)

def getOutput(status):
    global partyList
    output = '<h3><br/>'+status+'<br/><table border=1 align=center>'
    output+='<tr><th><font size=3 color=black>Candidate Name</font></th>'
    output+='<th><font size=3 color=black>Party Name</font></th>'
    output+='<th><font size=3 color=black>Area Name</font></th>'
    output+='<th><font size=3 color=black>Image</font></th>'
    output+='<th><font size=3 color=black>Cast Vote Here</font></th></tr>'
    for i in range(len(partyList)):
        pl = partyList[i]
        output+='<tr><td><font size=3 color=black>'+pl[0]+'</font></td>'
        output+='<td><font size=3 color=black>'+pl[1]+'</font></td>'
        output+='<td><font size=3 color=black>'+pl[2]+'</font></td>'
        output+='<td><img src="/static/parties/'+pl[3]+'" width=200 height=200></img></td>'
        output+='<td><a href="FinishVote?cname='+pl[0]+'&pname='+pl[1]+'"><font size=3 color=black>Click Here</font></a></td></tr>'
    output+="</table><br/><br/><br/><br/><br/><br/>"        
    return output   

def ValidateUser(request):
    if request.method == 'POST':
        global username, encodings, names
        predict = "none"
        page = "UserScreen.html"
        status = "unable to predict user"
        img = cv2.imread('VotingApp/static/photo/test.png')
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        face_component = None
        faces = face_detection.detectMultiScale(img,scaleFactor=1.1,minNeighbors=5,minSize=(30,30),flags=cv2.CASCADE_SCALE_IMAGE)
        status = "Unable to predict.Please retry"
        faces = sorted(faces, reverse=True,key=lambda x: (x[2] - x[0]) * (x[3] - x[1]))[0]
        (fX, fY, fW, fH) = faces
        face_component = gray[fY:fY + fH, fX:fX + fW]
        if face_component is not None:
            img = cv2.resize(img, (600, 600))
            rgb_small_frame = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convert the frame to RGB color space
            face_locations = face_recognition.face_locations(rgb_small_frame)  # Locate faces in the frame
            face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)  # Encode faces in the frame
            for face_encoding in face_encodings:
                matches = face_recognition.compare_faces(encodings, face_encoding)  # Compare face encodings
                face_distance = face_recognition.face_distance(encodings, face_encoding)  # Calculate face distance
                best_match_index = np.argmin(face_distance)  # Get the index of the best match
                print(best_match_index)
                if matches[best_match_index]:  # If the face is a match
                    name = names[best_match_index]  # Get the corresponding name
                    predict = name
                    break
        if predict == username:
            count = alreadyCastVote(username)
            if count == 0:
                page = 'VotePage.html'
                status = getOutput("User predicted as : "+predict+"<br/><br/>")
            else:
                status = "You already casted your vote"
                page = "UserScreen.html"
        else:
            page = "UserScreen.html"
            status = "unable to predict user"
        context= {'data':status}
        return render(request, page, context)

def UserLogin(request):
    if request.method == 'POST':
        global username, contract, usersList
        username = request.POST.get('username', False)
        password = request.POST.get('password', False)
        status = "Login.html"
        output = 'Invalid login details'
        for i in range(len(usersList)):
            ulist = usersList[i]
            user1 = ulist[0]
            pass1 = ulist[1]
            if user1 == username and pass1 == password:
                status = "UserScreen.html"
                output = 'Welcome '+username
                break        
        context= {'data':output}
        return render(request, status, context)

def AdminLogin(request):
    if request.method == 'POST':
        global username
        username = request.POST.get('username', False)
        password = request.POST.get('password', False)
        if username == 'admin' and password == 'admin':
            context= {'data':'Welcome '+username}
            return render(request, 'AdminScreen.html', context)
        if status == 'none':
            context= {'data':'Invalid login details'}
            return render(request, 'Admin.html', context)

def AddParty(request):
    if request.method == 'GET':
       return render(request, 'AddParty.html', {})

def index(request):
    if request.method == 'GET':
       return render(request, 'index.html', {})

def Login(request):
    if request.method == 'GET':
       return render(request, 'Login.html', {})

def CastVote(request):
    if request.method == 'GET':
       return render(request, 'CastVote.html', {})    

def AddVoter(request):
    if request.method == 'GET':
       return render(request, 'AddVoter.html', {})

def Admin(request):
    if request.method == 'GET':
       return render(request, 'Admin.html', {})

def AddVoterAction(request):
    if request.method == 'POST':
      global username, password, contact, email, aadhar, address, usersList
      username = request.POST.get('username', False)
      password = request.POST.get('password', False)
      contact = request.POST.get('contact', False)
      email = request.POST.get('email', False)
      aadhar=request.POST.get('aadhar',False)
      address = request.POST.get('address', False)
      status = "none"
      for i in range(len(usersList)):
          ul = usersList[i]
          if username == ul[0]:
              status = "exists"
              break
      if status == "none":
          context= {'data':'Capture Your face'}
          return render(request, 'CaptureFace.html', context)
      else:
          context= {'data':username+' Username already exists'}
          return render(request, 'AddVoter.html', context)

def WebCam(request):
    if request.method == 'GET':
        data = str(request)
        formats, imgstr = data.split(';base64,')
        imgstr = imgstr[0:(len(imgstr)-2)]
        data = base64.b64decode(imgstr)
        if os.path.exists("VotingApp/static/photo/test.png"):
            os.remove("VotingApp/static/photo/test.png")
        with open('VotingApp/static/photo/test.png', 'wb') as f:
            f.write(data)
        f.close()
        context= {'data':"done"}
        return HttpResponse("Image saved")        
    
def saveFace():
    global names, encodings
    encodings = np.asarray(encodings)
    names = np.asarray(names)
    np.save("model/encoding", encodings)
    np.save("model/names", names)

def saveUser(request):
    if request.method == 'POST':
        global username, password, contact, email, aadhar, address, usersList, encodings, names
        img = cv2.imread('VotingApp/static/photo/test.png')
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        face_component = None
        faces = face_detection.detectMultiScale(gray, 1.3,5)
        page = "AddVoter.html"
        status = 'Unable to detect face. Please retry'
        for (x, y, w, h) in faces:
            face_component = img[y:y+h, x:x+w]
        if face_component is not None:
            img = cv2.resize(img, (600, 600))
            if os.path.exists("VotingApp/static/photo/test.png"):
                os.remove("VotingApp/static/photo/test.png")
            cv2.imwrite("VotingApp/static/photo/test.png", img)
            image = face_recognition.load_image_file("VotingApp/static/photo/test.png")
            encoding = face_recognition.face_encodings(image)
            print("encoding "+str(encoding))
            if len(encoding) > 0 and username not in names:
                encoding = encoding[0]
                if len(encodings) == 0:
                    encodings.append(encoding)
                    names.append(username)
                else:
                    encodings = encodings.tolist()
                    names = names.tolist()
                    encodings.append(encoding)
                    names.append(username)
                saveFace()
                page = "AddVoter.html"
                status = 'User with Face Details added to Blockchain<br/><br/>'
                msg = contract.functions.createUser(username, email,password, aadhar, contact, address).transact()
                status += str(web3.eth.waitForTransactionReceipt(msg))
                usersList.append([username, password, email])
        context= {'data': status}
        return render(request, page, context)

def AddPartyAction(request):
    if request.method == 'POST':
        global partyList
        cname = request.POST.get('t1', False)
        pname = request.POST.get('t2', False)
        area = request.POST.get('t3', False)
        myfile = request.FILES['t4']
        imagename = request.FILES['t4'].name
        status = "none"
        page = "AddParty.html"
        for i in range(len(partyList)):
            pl = partyList[i]
            if cname == pl[0] and pname == pl[1]:
                status = "Candidate & Party Name Already Exists"
                break
        if status == "none":
            fs = FileSystemStorage()
            filename = fs.save('VotingApp/static/parties/'+imagename, myfile)
            status = 'Candidate details added to Blockchain<br/><br/>'
            msg = contract.functions.createParty(cname, pname, area, imagename).transact()
            status += str(web3.eth.waitForTransactionReceipt(msg))
            partyList.append([cname, pname, area, imagename])
        context= {'data': status}
        return render(request, page, context)

def getVoteCount(cname, pname):
    global voteList
    count = 0
    for i in range(len(voteList)):
        vl = voteList[i]
        if vl[1] == pname and vl[3] == cname:
            count += 1
    return count        

def ViewVotes(request):
    if request.method == 'GET':
        output = '<table border=1 align=center>'
        output+='<tr><th><font size=3 color=black>Candidate Name</font></th>'
        output+='<th><font size=3 color=black>Party Name</font></th>'
        output+='<th><font size=3 color=black>Area Name</font></th>'
        output+='<th><font size=3 color=black>Image</font></th>'
        output+='<th><font size=3 color=black>Vote Count</font></th>'
        for i in range(len(partyList)):
            pl = partyList[i]
            count = getVoteCount(pl[0], pl[1])
            output+='<tr><td><font size=3 color=black>'+pl[0]+'</font></td>'
            output+='<td><font size=3 color=black>'+pl[1]+'</font></td>'
            output+='<td><font size=3 color=black>'+pl[2]+'</font></td>'
            output+='<td><img src="/static/parties/'+pl[3]+'" width=200 height=200></img></td>'
            output+='<td><font size=3 color=black>'+str(count)+'</font></td></tr>'
        output+="</table><br/><br/><br/><br/><br/><br/>"        
        context= {'data':output}
        return render(request, 'ViewVotes.html', context)    
            
def ViewParty(request):
    if request.method == 'GET':
        output = '<table border=1 align=center>'
        output+='<tr><th><font size=3 color=black>Candidate Name</font></th>'
        output+='<th><font size=3 color=black>Party Name</font></th>'
        output+='<th><font size=3 color=black>Area Name</font></th>'
        output+='<th><font size=3 color=black>Image</font></th></tr>'
        for i in range(len(partyList)):
            pl = partyList[i]
            output+='<tr><td><font size=3 color=black>'+pl[0]+'</font></td>'
            output+='<td><font size=3 color=black>'+pl[1]+'</font></td>'
            output+='<td><font size=3 color=black>'+pl[2]+'</font></td>'
            output+='<td><img src="/static/parties/'+pl[3]+'" width=200 height=200></img></td></tr>'
        output+="</table><br/><br/><br/><br/><br/><br/>"        
        context= {'data':output}
        return render(request, 'ViewParty.html', context)    
\texfrom django.template import RequestContext
from django.template import RequestContext
from django.contrib import messages
from django.http import HttpResponse
from django.core.files.storage import FileSystemStorage
import os
from datetime import date
import cv2
import numpy as np
import base64
import random
from datetime import datetime
from PIL import Image
import json
from web3 import Web3, HTTPProvider
import face_recognition
global username, password, contact, email, aadhar, address, names, encodings
global contract, web3
global usersList, partyList, voteList
#function to call contract
def getContract():
    global contract, web3
    blockchain_address = 'http://127.0.0.1:9545'
    web3 = Web3(HTTPProvider(blockchain_address))
    web3.eth.defaultAccount = web3.eth.accounts[0]
    compiled_contract_path = 'Voting.json' #voting contract file
    deployed_contract_address = '0xd8a8e9202C03A93Eb20fEd7d34b84eDDE128c532' #contract address
    with open(compiled_contract_path) as file:
        contract_json = json.load(file)  # load contract info as JSON
        contract_abi = contract_json['abi']  # fetch contract's abi - necessary to call its functions
    file.close()
    contract = web3.eth.contract(address=deployed_contract_address, abi=contract_abi)
getContract()

def getUsersList():
    global usersList, contract
    usersList = []
    count = contract.functions.getUserCount().call()
    for i in range(0, count):
        user = contract.functions.getUsername(i).call()
        password = contract.functions.getPassword(i).call()
        email = contract.functions.getEmail(i).call()
        usersList.append([user, password, email,aadhar])

def getPartyList():
    global partyList, contract
    partyList = []
    count = contract.functions.getPartyCount().call()
    for i in range(0, count):
        cname = contract.functions.getCandidateName(i).call()
        pname = contract.functions.getPartyName(i).call()
        area = contract.functions.getArea(i).call()
        symbol = contract.functions.getSymbol(i).call()
        partyList.append([cname, pname, area, symbol])

def getVoteList():
    global voteList, contract
    voteList = []
    count = contract.functions.getVotingCount().call()
    for i in range(0, count):
        user = contract.functions.getUser(i).call()
        party = contract.functions.getParty(i).call()
        dd = contract.functions.getDate(i).call()
        candidate = contract.functions.getCandidate(i).call()
        voteList.append([user, party, dd, candidate])

def loadModel():
    global names, encodings
    if os.path.exists("model/encoding.npy"):
        encodings = np.load("model/encoding.npy")
        names = np.load("model/names.npy")        
    else:
        encodings = []
        names = []   

    
getUsersList()
getPartyList()        
getVoteList()
loadModel()

face_detection = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')

def alreadyCastVote(candidate):
    global voteList
    count = 0
    for i in range(len(voteList)):
        vl = voteList[i]
        if vl[3] == candidate:
            count = 1
    return count

def FinishVote(request):
    if request.method == 'GET':
        global username, voteList
        cname = request.GET.get('cname', False)
        pname = request.GET.get('pname', False)
        voter = ''
        today = date.today()
        status = 'Your vote casted to '+cname
        msg = contract.functions.createVote(username, pname, str(today), cname).transact()
        web3.eth.waitForTransactionReceipt(msg)
        voteList.append([username, pname, str(today), cname])
        context= {'data':'<font size=3 color=black>Your Vote Accepted for Candidate '+cname}
        return render(request, 'UserScreen.html', context)

def getOutput(status):
    global partyList
    output = '<h3><br/>'+status+'<br/><table border=1 align=center>'
    output+='<tr><th><font size=3 color=black>Candidate Name</font></th>'
    output+='<th><font size=3 color=black>Party Name</font></th>'
    output+='<th><font size=3 color=black>Area Name</font></th>'
    output+='<th><font size=3 color=black>Image</font></th>'
    output+='<th><font size=3 color=black>Cast Vote Here</font></th></tr>'
    for i in range(len(partyList)):
        pl = partyList[i]
        output+='<tr><td><font size=3 color=black>'+pl[0]+'</font></td>'
        output+='<td><font size=3 color=black>'+pl[1]+'</font></td>'
        output+='<td><font size=3 color=black>'+pl[2]+'</font></td>'
        output+='<td><img src="/static/parties/'+pl[3]+'" width=200 height=200></img></td>'
        output+='<td><a href="FinishVote?cname='+pl[0]+'&pname='+pl[1]+'"><font size=3 color=black>Click Here</font></a></td></tr>'
    output+="</table><br/><br/><br/><br/><br/><br/>"        
    return output   

def ValidateUser(request):
    if request.method == 'POST':
        global username, encodings, names
        predict = "none"
        page = "UserScreen.html"
        status = "unable to predict user"
        img = cv2.imread('VotingApp/static/photo/test.png')
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        face_component = None
        faces = face_detection.detectMultiScale(img,scaleFactor=1.1,minNeighbors=5,minSize=(30,30),flags=cv2.CASCADE_SCALE_IMAGE)
        status = "Unable to predict.Please retry"
        faces = sorted(faces, reverse=True,key=lambda x: (x[2] - x[0]) * (x[3] - x[1]))[0]
        (fX, fY, fW, fH) = faces
        face_component = gray[fY:fY + fH, fX:fX + fW]
        if face_component is not None:
            img = cv2.resize(img, (600, 600))
            rgb_small_frame = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convert the frame to RGB color space
            face_locations = face_recognition.face_locations(rgb_small_frame)  # Locate faces in the frame
            face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)  # Encode faces in the frame
            for face_encoding in face_encodings:
                matches = face_recognition.compare_faces(encodings, face_encoding)  # Compare face encodings
                face_distance = face_recognition.face_distance(encodings, face_encoding)  # Calculate face distance
                best_match_index = np.argmin(face_distance)  # Get the index of the best match
                print(best_match_index)
                if matches[best_match_index]:  # If the face is a match
                    name = names[best_match_index]  # Get the corresponding name
                    predict = name
                    break
        if predict == username:
            count = alreadyCastVote(username)
            if count == 0:
                page = 'VotePage.html'
                status = getOutput("User predicted as : "+predict+"<br/><br/>")
            else:
                status = "You already casted your vote"
                page = "UserScreen.html"
        else:
            page = "UserScreen.html"
            status = "unable to predict user"
        context= {'data':status}
        return render(request, page, context)

def UserLogin(request):
    if request.method == 'POST':
        global username, contract, usersList
        username = request.POST.get('username', False)
        password = request.POST.get('password', False)
        status = "Login.html"
        output = 'Invalid login details'
        for i in range(len(usersList)):
            ulist = usersList[i]
            user1 = ulist[0]
            pass1 = ulist[1]
            if user1 == username and pass1 == password:
                status = "UserScreen.html"
                output = 'Welcome '+username
                break        
        context= {'data':output}
        return render(request, status, context)

def AdminLogin(request):
    if request.method == 'POST':
        global username
        username = request.POST.get('username', False)
        password = request.POST.get('password', False)
        if username == 'admin' and password == 'admin':
            context= {'data':'Welcome '+username}
            return render(request, 'AdminScreen.html', context)
        if status == 'none':
            context= {'data':'Invalid login details'}
            return render(request, 'Admin.html', context)

def AddParty(request):
    if request.method == 'GET':
       return render(request, 'AddParty.html', {})

def index(request):
    if request.method == 'GET':
       return render(request, 'index.html', {})

def Login(request):
    if request.method == 'GET':
       return render(request, 'Login.html', {})

def CastVote(request):
    if request.method == 'GET':
       return render(request, 'CastVote.html', {})    

def AddVoter(request):
    if request.method == 'GET':
       return render(request, 'AddVoter.html', {})

def Admin(request):
    if request.method == 'GET':
       return render(request, 'Admin.html', {})

def AddVoterAction(request):
    if request.method == 'POST':
      global username, password, contact, email, aadhar, address, usersList
      username = request.POST.get('username', False)
      password = request.POST.get('password', False)
      contact = request.POST.get('contact', False)
      email = request.POST.get('email', False)
      aadhar=request.POST.get('aadhar',False)
      address = request.POST.get('address', False)
      status = "none"
      for i in range(len(usersList)):
          ul = usersList[i]
          if username == ul[0]:
              status = "exists"
              break
      if status == "none":
          context= {'data':'Capture Your face'}
          return render(request, 'CaptureFace.html', context)
      else:
          context= {'data':username+' Username already exists'}
          return render(request, 'AddVoter.html', context)

def WebCam(request):
    if request.method == 'GET':
        data = str(request)
        formats, imgstr = data.split(';base64,')
        imgstr = imgstr[0:(len(imgstr)-2)]
        data = base64.b64decode(imgstr)
        if os.path.exists("VotingApp/static/photo/test.png"):
            os.remove("VotingApp/static/photo/test.png")
        with open('VotingApp/static/photo/test.png', 'wb') as f:
            f.write(data)
        f.close()
        context= {'data':"done"}
        return HttpResponse("Image saved")        
    
def saveFace():
    global names, encodings
    encodings = np.asarray(encodings)
    names = np.asarray(names)
    np.save("model/encoding", encodings)
    np.save("model/names", names)

def saveUser(request):
    if request.method == 'POST':
        global username, password, contact, email, aadhar, address, usersList, encodings, names
        img = cv2.imread('VotingApp/static/photo/test.png')
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        face_component = None
        faces = face_detection.detectMultiScale(gray, 1.3,5)
        page = "AddVoter.html"
        status = 'Unable to detect face. Please retry'
        for (x, y, w, h) in faces:
            face_component = img[y:y+h, x:x+w]
        if face_component is not None:
            img = cv2.resize(img, (600, 600))
            if os.path.exists("VotingApp/static/photo/test.png"):
                os.remove("VotingApp/static/photo/test.png")
            cv2.imwrite("VotingApp/static/photo/test.png", img)
            image = face_recognition.load_image_file("VotingApp/static/photo/test.png")
            encoding = face_recognition.face_encodings(image)
            print("encoding "+str(encoding))
            if len(encoding) > 0 and username not in names:
                encoding = encoding[0]
                if len(encodings) == 0:
                    encodings.append(encoding)
                    names.append(username)
                else:
                    encodings = encodings.tolist()
                    names = names.tolist()
                    encodings.append(encoding)
                    names.append(username)
                saveFace()
                page = "AddVoter.html"
                status = 'User with Face Details added to Blockchain<br/><br/>'
                msg = contract.functions.createUser(username, email,password, aadhar, contact, address).transact()
                status += str(web3.eth.waitForTransactionReceipt(msg))
                usersList.append([username, password, email])
        context= {'data': status}
        return render(request, page, context)

def AddPartyAction(request):
    if request.method == 'POST':
        global partyList
        cname = request.POST.get('t1', False)
        pname = request.POST.get('t2', False)
        area = request.POST.get('t3', False)
        myfile = request.FILES['t4']
        imagename = request.FILES['t4'].name
        status = "none"
        page = "AddParty.html"
        for i in range(len(partyList)):
            pl = partyList[i]
            if cname == pl[0] and pname == pl[1]:
                status = "Candidate & Party Name Already Exists"
                break
        if status == "none":
            fs = FileSystemStorage()
            filename = fs.save('VotingApp/static/parties/'+imagename, myfile)
            status = 'Candidate details added to Blockchain<br/><br/>'
            msg = contract.functions.createParty(cname, pname, area, imagename).transact()
            status += str(web3.eth.waitForTransactionReceipt(msg))
            partyList.append([cname, pname, area, imagename])
        context= {'data': status}
        return render(request, page, context)

def getVoteCount(cname, pname):
    global voteList
    count = 0
    for i in range(len(voteList)):
        vl = voteList[i]
        if vl[1] == pname and vl[3] == cname:
            count += 1
    return count        

def ViewVotes(request):
    if request.method == 'GET':
        output = '<table border=1 align=center>'
        output+='<tr><th><font size=3 color=black>Candidate Name</font></th>'
        output+='<th><font size=3 color=black>Party Name</font></th>'
        output+='<th><font size=3 color=black>Area Name</font></th>'
        output+='<th><font size=3 color=black>Image</font></th>'
        output+='<th><font size=3 color=black>Vote Count</font></th>'
        for i in range(len(partyList)):
            pl = partyList[i]
            count = getVoteCount(pl[0], pl[1])
            output+='<tr><td><font size=3 color=black>'+pl[0]+'</font></td>'
            output+='<td><font size=3 color=black>'+pl[1]+'</font></td>'
            output+='<td><font size=3 color=black>'+pl[2]+'</font></td>'
            output+='<td><img src="/static/parties/'+pl[3]+'" width=200 height=200></img></td>'
            output+='<td><font size=3 color=black>'+str(count)+'</font></td></tr>'
        output+="</table><br/><br/><br/><br/><br/><br/>"        
        context= {'data':output}
        return render(request, 'ViewVotes.html', context)    
            
def ViewParty(request):
    if request.method == 'GET':
        output = '<table border=1 align=center>'
        output+='<tr><th><font size=3 color=black>Candidate Name</font></th>'
        output+='<th><font size=3 color=black>Party Name</font></th>'
        output+='<th><font size=3 color=black>Area Name</font></th>'
        output+='<th><font size=3 color=black>Image</font></th></tr>'
        for i in range(len(partyList)):
            pl = partyList[i]
            output+='<tr><td><font size=3 color=black>'+pl[0]+'</font></td>'
            output+='<td><font size=3 color=black>'+pl[1]+'</font></td>'
            output+='<td><font size=3 color=black>'+pl[2]+'</font></td>'
            output+='<td><img src="/static/parties/'+pl[3]+'" width=200 height=200></img></td></tr>'
        output+="</table><br/><br/><br/><br/><br/><br/>"        
        context= {'data':output}
        return render(request, 'ViewParty.html', context)    
\textbf{\large 5.2 Voting.sol}
pragma solidity >= 0.8.11 <= 0.8.11;
pragma experimental ABIEncoderV2;
//cheque solidity code
contract Voting {
      uint public partyCount = 0; 
    mapping(uint => party) public partyList; 
     struct party
     {
       string candidate;
       string partyname;
       string areaname;
       string symbol;       
     }

   // events 
   event partyCreated(uint indexed _partyId);
   //function  to save party details
   function createParty(string memory cn, string memory pn, string memory an, string memory sy) public {
      partyList[partyCount] = party(cn, pn, an, sy);
      emit partyCreated(partyCount);
      partyCount++;
    }

     //get Party count
    function getPartyCount()  public view returns (uint) {
          return  partyCount;
    }

    function getCandidateName(uint i) public view returns (string memory) {
        party memory chq = partyList[i];
	return chq.candidate;
    }

    function getPartyName(uint i) public view returns (string memory) {
        party memory chq = partyList[i];
	return chq.partyname;
    }

    function getArea(uint i) public view returns (string memory) {
        party memory chq = partyList[i];
	return chq.areaname;
    }

    function getSymbol(uint i) public view returns (string memory) {
        party memory chq = partyList[i];
	return chq.symbol;
    } 

    uint public votingCount = 0; 
    mapping(uint => voting) public votingList; 
     struct voting
     {
       string user;
       string party;
       string date;
       string candidate;       
     }
 
   // events 
   event voteCreated(uint indexed _voteId);

   //function  to save vote details
   function createVote(string memory usr, string memory party, string memory dd, string memory candidate) public {
      votingList[votingCount] = voting(usr, party, dd, candidate);
      emit voteCreated(votingCount);
      votingCount++;
    }

     //get Vote count
    function getVotingCount()  public view returns (uint) {
          return  votingCount;
    }

    function getUser(uint i) public view returns (string memory) {
        voting memory chq = votingList[i];
	return chq.user;
    }

    function getParty(uint i) public view returns (string memory) {
        voting memory chq = votingList[i];
	return chq.party;
    }

    function getDate(uint i) public view returns (string memory) {
        voting memory chq = votingList[i];
	return chq.date;
    }

    function getCandidate(uint i) public view returns (string memory) {
        voting memory chq = votingList[i];
	return chq.candidate;
    }     
       
    uint public userCount = 0; 
    mapping(uint => user) public usersList; 
     struct user
     {
       string username;
       string email;
       string password;
       string aadhar;
       string phone;
       string home_address;       
     }
 
   // events
 
   event userCreated(uint indexed _userId);
  function createUser(string memory _username, string memory _email, string memory _password, string memory_aadhar, string memory _phone, string memory _address) public {
      usersList[userCount] = user(_username, _email, _password, _aadhar, _phone, _address);
      emit userCreated(userCount);
      userCount++;
    }

     //get user count
    function getUserCount()  public view returns (uint) {
          return  userCount;
    }
    function getUsername(uint i) public view returns (string memory) {
        user memory usr = usersList[i];
	return usr.username;
    }
    function getPassword(uint i) public view returns (string memory) {
        user memory usr = usersList[i];
	return usr.password;
    }
    function getEmail(uint i) public view returns (string memory) {
        user memory usr = usersList[i];
	return usr.email;
    }
    function getAadhar(uint i) public view returns (string memory) {
        user memory usr = usersList[i];
	return usr.aadhar;
    }
}
pragma solidity >= 0.8.11 <= 0.8.11;
pragma experimental ABIEncoderV2;
//cheque solidity code
contract Voting {
      uint public partyCount = 0; 
    mapping(uint => party) public partyList; 
     struct party
     {
       string candidate;
       string partyname;
       string areaname;
       string symbol;       
     }

   // events 
   event partyCreated(uint indexed _partyId);
   //function  to save party details
   function createParty(string memory cn, string memory pn, string memory an, string memory sy) public {
      partyList[partyCount] = party(cn, pn, an, sy);
      emit partyCreated(partyCount);
      partyCount++;
    }

     //get Party count
    function getPartyCount()  public view returns (uint) {
          return  partyCount;
    }

    function getCandidateName(uint i) public view returns (string memory) {
        party memory chq = partyList[i];
	return chq.candidate;
    }

    function getPartyName(uint i) public view returns (string memory) {
        party memory chq = partyList[i];
	return chq.partyname;
    }

    function getArea(uint i) public view returns (string memory) {
        party memory chq = partyList[i];
	return chq.areaname;
    }

    function getSymbol(uint i) public view returns (string memory) {
        party memory chq = partyList[i];
	return chq.symbol;
    } 

    uint public votingCount = 0; 
    mapping(uint => voting) public votingList; 
     struct voting
     {
       string user;
       string party;
       string date;
       string candidate;       
     }
 
   // events 
   event voteCreated(uint indexed _voteId);

   //function  to save vote details
   function createVote(string memory usr, string memory party, string memory dd, string memory candidate) public {
      votingList[votingCount] = voting(usr, party, dd, candidate);
      emit voteCreated(votingCount);
      votingCount++;
    }

     //get Vote count
    function getVotingCount()  public view returns (uint) {
          return  votingCount;
    }

    function getUser(uint i) public view returns (string memory) {
        voting memory chq = votingList[i];
	return chq.user;
    }

    function getParty(uint i) public view returns (string memory) {
        voting memory chq = votingList[i];
	return chq.party;
    }

    function getDate(uint i) public view returns (string memory) {
        voting memory chq = votingList[i];
	return chq.date;
    }

    function getCandidate(uint i) public view returns (string memory) {
        voting memory chq = votingList[i];
	return chq.candidate;
    }     
       
    uint public userCount = 0; 
    mapping(uint => user) public usersList; 
     struct user
     {
       string username;
       string email;
       string password;
       string aadhar;
       string phone;
       string home_address;       
     }
 
   // events
 
   event userCreated(uint indexed _userId);
  function createUser(string memory _username, string memory _email, string memory _password, string memory_aadhar, string memory _phone, string memory _address) public {
      usersList[userCount] = user(_username, _email, _password, _aadhar, _phone, _address);
      emit userCreated(userCount);
      userCount++;
    }

     //get user count
    function getUserCount()  public view returns (uint) {
          return  userCount;
    }
    function getUsername(uint i) public view returns (string memory) {
        user memory usr = usersList[i];
	return usr.username;
    }
    function getPassword(uint i) public view returns (string memory) {
        user memory usr = usersList[i];
	return usr.password;
    }
    function getEmail(uint i) public view returns (string memory) {
        user memory usr = usersList[i];
	return usr.email;
    }
    function getAadhar(uint i) public view returns (string memory) {
        user memory usr = usersList[i];
	return usr.aadhar;
    }
}
Add Party.html
{% load static %}
<html>
<head>
<title>Secure Digital Voting System Using Blockchain</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="{% static 'style.css' %}"/>
 <script LANGUAGE="Javascript" >
function validate(){
	var x=document.forms["f1"]["t1"].value;
	var y=document.forms["f1"]["t2"].value;
	var c=document.forms["f1"]["t3"].value;
	var e=document.forms["f1"]["t4"].value;
	if(x == null || x==""){
		window.alert("candidate name must be enter");
		document.f1.username.focus();
		return false;
	}
	if(y == null || y==""){
		window.alert("party name must be enter");
		document.f1.password.focus();
		return false;
	}
	if(c == null || c==""){
		window.alert("area name must be enter");
		document.f1.contact.focus();
		return false;
	}
	
	if(e == null || e==""){
		window.alert("image must be upload");
		document.f1.email.focus();
		return false;
	}
	return true;
}
</script>

</head>
<body>
<div id="wrapper">
	<div id="header">
		<div id="logo">
			<center><font size="6" color="Radium">Secure Digital Voting System Using Blockchain</font></center>
		</div>
		<div id="slogan">
	
		</div>
	</div>
	<div id="menu">
		<ul><center>
      <li><a href="{% url 'AddParty' %}">Add Party Details</a></li>
	   <li><a href="{% url 'AddVoter' %}">Add Voter with Face</a></li>
	  <li><a href="{% url 'ViewParty' %}">View Party Details</a></li>
	  <li><a href="{% url 'ViewVotes' %}">View Votes</a></li>
	  <li><a href="{% url 'index' %}">Logout</a></li>		
		</center></ul>
<br class="clearfix" />
				</div>
			
	<div id="splash">
		<img class="pic" src="{% static 'images/investor.png' %}" width="870" height="230" alt="" />
	</div>	
			<center>
<form name="f1" method="post" action={% url 'AddPartyAction' %} enctype="multipart/form-data" OnSubmit="return validate()">
	{% csrf_token %}<br/>
   <h3><b>Add Party Candidate Screen</b></h3>
   
	<font size="" color="black"><center>{{ data|safe }}</center></font>
						
						<table align="center" width="80" >
			 <tr><td><font size="3" color="black">Candidate&nbsp;Name</b></td><td><input type="text" name="t1" style="font-family: Comic Sans MS" size="30"/></td></tr>	  
		<tr><td><font size="3" color="black">Party&nbsp;Name</b></td><td><select name="t2">
		<option value="Flower">Flower</option>
		<option value="Bottle">Bottle</option>
		<option value="Bird">Bird</option>
		</select>
		</td></tr>

		
		<tr><td><font size="3" color="black">Area&nbsp;Name</b></td><td><input type="text" name="t3" style="font-family: Comic Sans MS" size="20"/></td></tr>

		<tr><td><font size="3" color="black">Profile&nbsp;Image</b></td><td><input type="file" name="t4" style="font-family: Comic Sans MS" size="60"/></td></tr>
		
		         
			<tr><td></td><td><input type="submit" value="Add Party">
			</td>
			</table>
			<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
				</div>	
					
				</div>			
	</body>
</html>
Add Voter.hmtl
{% load static %}
<html>
<head>
<title>Secure Digital Voting System Using Blockchain</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="{% static 'style.css' %}"/>
 <script LANGUAGE="Javascript" >
function validate(){
	var x=document.forms["f1"]["username"].value;
	var y=document.forms["f1"]["password"].value;
	var c=document.forms["f1"]["contact"].value;
	var e=document.forms["f1"]["email"].value;
	var d=documnet.forms["f1"]["aadhar"].value;
	var a=document.forms["f1"]["address"].value;
	var image=document.forms["f1"]["image"].value;
	if(x == null || x==""){
		window.alert("Username must be enter");
		document.f1.username.focus();
		return false;
	}
	if(y == null || y==""){
		window.alert("Password must be enter");
		document.f1.password.focus();
		return false;
	}
	if(c == null || c==""){
		window.alert("Contact No must be enter");
		document.f1.contact.focus();
		return false;
	}
	if(isNaN(c)){
		window.alert("Please enter valid contact number");
		document.f1.contact.focus();
		return false;
	}
	if(e == null || e==""){
		window.alert("Email ID must be enter");
		document.f1.email.focus();
		return false;
	}
	var filter = /^([a-zA-Z0-9_\.\-])+\@(gmail+\.)+(com)+$/;
	if (!filter.test(e)) {
		window.alert('enter a valid email address');
		document.f1.email.focus();
		return false;
	}
	if(a == null || a==""){
		window.alert("Address must be enter");
		document.f1.address.focus();
		return false;
	}
	return true;
}
</script>

</head>
<body>
<div id="wrapper">
	<div id="header">
		<div id="logo">
			<center><font size="6" color="Radium">Secure Digital Voting System Using Blockchain</font></center>
		</div>
		<div id="slogan">
			
		</div>
	</div>
	<div id="menu">
		<ul><center>
      <li><a href="{% url 'AddParty' %}">Add Party Details</a></li>
	   <li><a href="{% url 'AddVoter' %}">Add Voter with Face</a></li>
	  <li><a href="{% url 'ViewParty' %}">View Party Details</a></li>
	  <li><a href="{% url 'ViewVotes' %}">View Votes</a></li>
	  <li><a href="{% url 'index' %}">Logout</a></li>		
		</center></ul>
<br class="clearfix" />
				</div>
			
	<div id="splash">
		<img class="pic" src="{% static 'images/investor.png' %}" width="870" height="230" alt="" />
	</div>	
			<center>
<form name="f1" method="post" action={% url 'AddVoterAction' %} OnSubmit="return validate()">
	{% csrf_token %}<br/>
   <h3><b>New User Signup Screen</b></h3>
   
	<font size="" color="black"><center>{{ data|safe }}</center></font>
						
						<table align="center" width="80" >
			 <tr><td><font size="3" color="black">Username</b></td><td><input type="text" name="username" style="font-family: Comic Sans MS" size="30"/></td></tr>
         
		  
		<tr><td><font size="3" color="black">Password</b></td><td><input type="password" name="password" style="font-family: Comic Sans MS" size="30"/></td></tr>

		
		<tr><td><font size="3" color="black">Contact&nbsp;No</b></td><td><input type="text" name="contact" style="font-family: Comic Sans MS" size="20"/></td></tr>

		<tr><td><font size="3" color="black">Email&nbsp;ID</b></td><td><input type="text" name="email" style="font-family: Comic Sans MS" size="40"/></td></tr>
		<tr><td><font size="3" color="black">Aadhar&nbsp;No</b></td><td><input type="text" name="aadhar" style="font-family: Comic Sans MS" size="40"/></td></tr>	
		<tr><td><font size="3" color="black">Address</b></td><td><input type="text" name="address" style="font-family: Comic Sans MS" size="60"/></td></tr>

		
			<tr><td></td><td><input type="submit" value="Register">
			</td>
			</table>
			<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
				</div>	
					
				</div>			
	</body>
</html>
Admin Screen.hmtl
{% load static %}
<html>
<head>
<title>Secure Digital Voting System Using Blockchain</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="{% static 'style.css' %}"/>
</head>
<body>
<div id="wrapper">
	<div id="header">
		<div id="logo">
			<center><font size="6" color="Radium">Secure Digital Voting System Using Blockchain</font></center>
		</div>
		<div id="slogan">
			
		</div>
	</div>
	<div id="menu">
		<ul><center>
      <li><a href="{% url 'AddParty' %}">Add Party Details</a></li>
	   <li><a href="{% url 'AddVoter' %}">Add Voter with Face</a></li>
	  <li><a href="{% url 'ViewParty' %}">View Party Details</a></li>
	  <li><a href="{% url 'ViewVotes' %}">View Votes</a></li>
	  <li><a href="{% url 'index' %}">Logout</a></li>		
		</center></ul>
		<br class="clearfix" />
	</div>
	<div id="splash">
		<img class="pic" src="{% static 'images/investor.png' %}" width="870" height="230" alt="" />
	</div>
	<br/>
	{{ data|safe }}
</body>
</html>
Capture face.html
{% load static %}
<!doctype html>

<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Secure Digital Voting System Using Blockchain</title>
	<style type="text/css">
		body { font-family: Helvetica, sans-serif; }
		h2, h3 { margin-top:0; }
		form { margin-top: 15px; }
		form > input { margin-right: 15px; }
		#results { float:right; margin:20px; padding:20px; border:1px solid; background:#ccc; }
	</style>
	<script type="text/javascript" src="{% static 'webcam.min.js' %}"></script>
	<script language="JavaScript">
		function take_snapshot() {
			// take snapshot and get image data
			Webcam.snap( function(data_uri) {
				// display results in page
				document.getElementById('results').innerHTML = 
					'<h2>Here is your image:</h2>' + 
					'<img src="'+data_uri+'"/>';
					var request = new XMLHttpRequest();
 request.open("GET", "http://127.0.0.1:8000/WebCam?mytext="+data_uri);
 //window.alert(data_uri)
 request.onreadystatechange = function() {
 if(this.readyState === 4 && this.status === 200) {
 	    data = this.responseText
		document.getElementById("sr").innerHTML = data;
        }
    };
	request.send();
					
			} );
		}

	</script>
</head>
<body>
	<div id="results">Your captured image will appear here...</div>
	
	<h1>Secure Digital Voting System Using Blockchain</h1>
	<h3>Demonstrates simple 320x240 capture &amp; display</h3>
	
	<div id="my_camera"></div>
	
	<!-- First, include the Webcam.js JavaScript Library -->
	
	
	<!-- Configure a few settings and attach camera -->
	<script language="JavaScript">
		Webcam.set({
			width: 320,
			height: 240,
			image_format: 'jpeg',
			jpeg_quality: 90
		});
		Webcam.attach( '#my_camera' );
	</script>
	
	<!-- A button for taking snaps -->
	<form>
		<input type=button value="Take Snapshot" onClick="take_snapshot()">
		<div id="sr">Server Response</div>
	</form>
<form  name="f1" method="post" action="{% url 'saveUser' %}"> 
<br/>
			{% csrf_token %}<br/>
<input type="submit" value="Click Here to Complete Signup Task"></input>
</form>		
</body>
</html>
Cate Vote.html
{% load static %}
<!doctype html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Secure Digital Voting System Using Blockchain</title>
	<style type="text/css">
		body { font-family: Helvetica, sans-serif; }
		h2, h3 { margin-top:0; }
		form { margin-top: 15px; }
		form > input { margin-right: 15px; }
		#results { float:right; margin:20px; padding:20px; border:1px solid; background:#ccc; }
	</style>
	<script type="text/javascript" src="{% static 'webcam.min.js' %}"></script>
	<script language="JavaScript">
		function take_snapshot() {
			// take snapshot and get image data
			Webcam.snap( function(data_uri) {
				// display results in page
				document.getElementById('results').innerHTML = 
					'<h2>Here is your image:</h2>' + 
					'<img src="'+data_uri+'"/>';
					var request = new XMLHttpRequest();
 request.open("GET", "http://127.0.0.1:8000/WebCam?mytext="+data_uri);
 //window.alert(data_uri)
 request.onreadystatechange = function() {
 if(this.readyState === 4 && this.status === 200) {
 	    data = this.responseText
		document.getElementById("sr").innerHTML = data;
        }
    };
	request.send();				
			} );
		}
	</script>
</head>
<body>
	<div id="results">Your captured image will appear here...</div>
	
	<h1>Secure Digital Voting System Using Blockchain</h1>
	<h3>Demonstrates simple 320x240 capture &amp; display</h3>
	
	<div id="my_camera"></div>
	
	<!-- First, include the Webcam.js JavaScript Library -->
	
	
	<!-- Configure a few settings and attach camera -->
	<script language="JavaScript">
		Webcam.set({
			width: 320,
			height: 240,
			image_format: 'jpeg',
			jpeg_quality: 90
		});
		Webcam.attach( '#my_camera' );
	</script>
	
	<!-- A button for taking snaps -->
	<form>
		<input type=button value="Take Snapshot" onClick="take_snapshot()">
		<div id="sr">Server Response</div>
	</form>
<form  name="f1" method="post" action="{% url 'ValidateUser' %}"> 
<br/>
{% csrf_token %}<br/>
<input type="submit" value="Validate User"></input>
</form>		
</body>
</html>
style.css
* {
	margin: 0;
	padding: 0;
}
a {
	text-decoration: underline;
	color: #0F8C8C;
}
a:hover {
	text-decoration: none;
}
body {
	font-size: 11.5pt;
	color: #5C5B5B;
	line-height: 1.75em;
	background: #E0DCDC url(images/img01.gif) ;
}
body,input {
	font-family: Georgia, serif;
}
strong {
	color: #2C2B2B;
}
br.clearfix {
	clear: both;
}
h1,h2,h3,h4 {
	font-weight: normal;
	letter-spacing: -1px;
}
h2 {
	font-size: 2.25em;
}
h2,h3,h4 {
	color: #2C2B2B;
	margin-bottom: 1em;
}
h3 {
	font-size: 1.75em;
}
h4 {
	font-size: 1.5em;
}
img.alignleft {
	margin: 5px 20px 20px 0;
	float: left;
}
img.aligntop {
	margin: 5px 0 20px 0;
}
img.pic {
	padding: 5px;
	border: solid 1px #D4D4D4;
}
p {
	margin-bottom: 1.5em;
}
ul {
	margin-bottom: 1.5em;
}
ul h4 {
	margin-bottom: 0.35em;
}
.box {
	overflow: hidden;
	margin-bottom: 1em;
}
.date {
	background: #6E6E6E;
	padding: 5px 6px 5px 6px;
	margin: 0 6px 0 0;
	color: #FFFFFF;
	font-size: 0.8em;
	border-radius: 2px;
}
#content {
	width: 665px;
	float: left;
	padding: 0;
}
#content-box1 {
	width: 320px;
	float: left;
}
#content-box2 {
	margin: 0 0 0 345px;
	width: 320px;
}
#footer {
	margin: 40px 0 120px 0;
	text-align: center;
	color: #8C8B8B;
}
#footer a {
	color: #8C8B8B;
}
#header {
	height: 75px;
	position: relative;
	background: #6E6E6E url(images/img03.jpeg) ;
	padding: 45px;
	color: #FFFFFF;
	width: 888px;
	border: solid 1px #7E7E7E;
	border-top-left-radius: 5px;
	border-top-right-radius: 5px;
	overflow: hidden;
}
#logo {
	line-height: 160px;
	height: 160px;
	padding: 5px 0 0 0;
	position: absolute;
	top: 0;
	left: 45px;
}
#logo a {
	text-decoration: none;
	color: #FFFFFF;
	text-shadow: 0 1px 1px #3E3E3E;
}
#logo h1 {
	font-size: 2.25em;
}
#slogan {
	line-height: 160px;
	height: 160px;
	padding: 5px 0 0 0;
	position: absolute;
	right: 45px;
	top: 0;
}
#slogan h2 {
	color: #BEBEBE;
	font-size: 1.25em;
	text-shadow: 0 1px 1px #3E3E3E;
}
#menu {
	padding: 0 45px 0 45px;
	position: relative;
	background: url(images/img01.gif) repeat-x top left;
	margin: 0 0 0 0;
	height: 60px;
	line-height: 60px;
	width: 890px;
	border-top: solid 1px #5AD7D7;
	text-shadow: 0 1px 1px #007D7D;
}
#menu a {
	text-decoration: none;
	color: #FFFFFF;
	font-size: 1.25em;
	letter-spacing: -1px;
}
#menu ul {
	list-style: none;
}
#menu ul li {
	padding: 0 20px 0 20px;
	display: inline;
}
#menu ul li.first {
	padding-left: 0;
}
#page {
	padding: 45px 45px 15px 45px;
	position: relative;
	width: 890px;
	margin: 0;
}
#page .section-list {
	list-style: none;
	padding-left: 0;
}
#page .section-list li {
	clear: both;
	padding: 30px 0 30px 0;
}
#page ul {
	list-style: none;
}
#page ul li {
	border-top: solid 1px #D4D4D4;
	padding: 15px 0 15px 0;
}
#page ul li.first {
	padding-top: 0;
	border-top: 0;
}
#page-bottom {
	position: relative;
	margin: 0;
	background: #6E6E6E url(images/img03.jpeg) top left no-repeat;
	border: solid 1px #7E7E7E;
	width: 888px;
	padding: 45px 45px 0 45px;
	color: #DCDCDC;
	border-bottom-left-radius: 5px;
	border-bottom-right-radius: 5px;
}
#page-bottom a {
	color: #F5F5F5;
}
#page-bottom h2, #page-bottom h3, #page-bottom h4 {
	color: #FFFFFF;
}
#page-bottom ul {
	list-style: none;
}
#page-bottom ul li {
	border-top: solid 1px #8F8F8F;
	padding: 15px 0 15px 0;
}
#page-bottom ul li.first {
	padding-top: 0;
	border-top: 0;
}
#page-bottom-content {
	width: 665px;
	float: left;
}
#page-bottom-sidebar {
	width: 200px;
	margin: 0 0 0 690px;
}
#search input.form-submit {
	margin-left: 1em;
	color: #FFFFFF;
	padding: 10px;
	background: #2FACAC;
	border: 0;
}
#search input.form-text {
	border: solid 1px #8F8F8F;
	padding: 10px;
}
#sidebar {
	width: 200px;
	padding: 0;
	margin: 0 0 0 690px;
}
#splash {
	margin: 0 0 0 0;
	height: 250px;
	position: relative;
	padding: 45px 45px 10px 45px;
	width: 890px;
}
#splash .pic {
	padding: 9px;
}
#wrapper {
	position: relative;
	width: 980px;
	margin: 75px auto 0 auto;
	background: #D6BBB6;
}
